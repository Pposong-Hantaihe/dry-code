"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const rabin_karp_1 = require("./rabin-karp");
const validators_1 = require("./validators");
const mode_1 = require("./mode");
// TODO replace to own event emitter
const EventEmitter = require("eventemitter3");
class Detector extends EventEmitter {
    constructor(tokenizer, store, cloneValidators = [], options) {
        super();
        this.tokenizer = tokenizer;
        this.store = store;
        this.cloneValidators = cloneValidators;
        this.options = options;
        this.initCloneValidators();
        this.algorithm = new rabin_karp_1.RabinKarp(this.options, this, this.cloneValidators);
        this.options.minTokens = this.options.minTokens || 50;
        this.options.maxLines = this.options.maxLines || 500;
        this.options.minLines = this.options.minLines || 5;
        this.options.mode = this.options.mode || mode_1.mild;
    }
    detect(id, text, format) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenMaps = this.tokenizer.generateMaps(id, text, format, this.options);
            // TODO change stores implementation
            this.store.namespace(format);
            const detect = (tokenMap, clones) => __awaiter(this, void 0, void 0, function* () {
                if (tokenMap) {
                    this.emit('START_DETECTION', { source: tokenMap });
                    return this.algorithm
                        .run(tokenMap, this.store)
                        .then((clns) => {
                        clones.push(...clns);
                        const nextTokenMap = tokenMaps.pop();
                        if (nextTokenMap) {
                            return detect(nextTokenMap, clones);
                        }
                        else {
                            return clones;
                        }
                    });
                }
            });
            return detect(tokenMaps.pop(), []);
        });
    }
    initCloneValidators() {
        if (this.options.minLines || this.options.maxLines) {
            this.cloneValidators.push(new validators_1.LinesLengthCloneValidator());
        }
    }
}
exports.Detector = Detector;
//# sourceMappingURL=detector.js.map