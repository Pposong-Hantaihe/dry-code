"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const validators_1 = require("./validators");
class RabinKarp {
    constructor(options, eventEmitter, cloneValidators) {
        this.options = options;
        this.eventEmitter = eventEmitter;
        this.cloneValidators = cloneValidators;
    }
    run(tokenMap, store) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve => {
                let mapFrameInStore;
                let clone = null;
                const clones = [];
                // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
                const loop = () => {
                    const iteration = tokenMap.next();
                    store
                        .get(iteration.value.id)
                        .then((mapFrameFromStore) => {
                        mapFrameInStore = mapFrameFromStore;
                        if (!clone) {
                            clone = RabinKarp.createClone(tokenMap.getFormat(), iteration.value, mapFrameInStore);
                        }
                    }, () => {
                        if (clone && this.validate(clone)) {
                            clones.push(clone);
                        }
                        clone = null;
                        if (iteration.value.id) {
                            return store.set(iteration.value.id, iteration.value);
                        }
                    })
                        .finally(() => {
                        if (!iteration.done) {
                            if (clone) {
                                clone = RabinKarp.enlargeClone(clone, iteration.value, mapFrameInStore);
                            }
                            loop();
                        }
                        else {
                            resolve(clones);
                        }
                    });
                };
                loop();
            }));
        });
    }
    validate(clone) {
        const validation = validators_1.runCloneValidators(clone, this.options, this.cloneValidators);
        if (validation.status) {
            this.eventEmitter.emit('CLONE_FOUND', { clone });
        }
        else {
            this.eventEmitter.emit('CLONE_SKIPPED', { clone, validation });
        }
        return validation.status;
    }
    static createClone(format, mapFrameA, mapFrameB) {
        return {
            format,
            foundDate: new Date().getTime(),
            duplicationA: {
                sourceId: mapFrameA.sourceId,
                start: mapFrameA.start.loc.start,
                end: mapFrameA.end.loc.end,
                range: [mapFrameA.start.range[0], mapFrameA.end.range[1]],
            },
            duplicationB: {
                sourceId: mapFrameB.sourceId,
                start: mapFrameB.start.loc.start,
                end: mapFrameB.end.loc.end,
                range: [mapFrameB.start.range[0], mapFrameB.end.range[1]],
            },
        };
    }
    static enlargeClone(clone, mapFrameA, mapFrameB) {
        clone.duplicationA.range[1] = mapFrameA.end.range[1];
        clone.duplicationA.end = mapFrameA.end.loc.end;
        clone.duplicationB.range[1] = mapFrameB.end.range[1];
        clone.duplicationB.end = mapFrameB.end.loc.end;
        return clone;
    }
}
exports.RabinKarp = RabinKarp;
//# sourceMappingURL=rabin-karp.js.map