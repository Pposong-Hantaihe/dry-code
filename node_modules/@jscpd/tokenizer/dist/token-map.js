"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const hash_1 = require("./hash");
const TOKEN_HASH_LENGTH = 20;
function createTokenHash(token, hashFunction = undefined) {
    return hashFunction ?
        hashFunction(token.type + token.value).substr(0, TOKEN_HASH_LENGTH) :
        hash_1.hash(token.type + token.value).substr(0, TOKEN_HASH_LENGTH);
}
function groupByFormat(tokens) {
    const result = {};
    // TODO change to reduce
    tokens.forEach((token) => {
        (result[token.format] = result[token.format] ? [...result[token.format], token] : [token]);
    });
    return result;
}
class TokensMap {
    constructor(id, data, tokens, format, options) {
        this.id = id;
        this.data = data;
        this.tokens = tokens;
        this.format = format;
        this.options = options;
        this.position = 0;
        this.hashMap = this.tokens.map((token) => {
            if (options.ignoreCase) {
                token.value = token.value.toLocaleLowerCase();
            }
            return createTokenHash(token, this.options.hashFunction);
        }).join('');
    }
    getTokensCount() {
        return this.tokens[this.tokens.length - 1].loc.end.position - this.tokens[0].loc.start.position;
    }
    getId() {
        return this.id;
    }
    getLinesCount() {
        return this.tokens[this.tokens.length - 1].loc.end.line - this.tokens[0].loc.start.line;
    }
    getFormat() {
        return this.format;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        const hashFunction = this.options.hashFunction ? this.options.hashFunction : hash_1.hash;
        const mapFrame = hashFunction(this.hashMap.substring(this.position * TOKEN_HASH_LENGTH, this.position * TOKEN_HASH_LENGTH + this.options.minTokens * TOKEN_HASH_LENGTH)).substring(0, TOKEN_HASH_LENGTH);
        if (this.position < this.tokens.length - this.options.minTokens) {
            this.position++;
            return {
                done: false,
                value: {
                    id: mapFrame,
                    sourceId: this.getId(),
                    start: this.tokens[this.position - 1],
                    end: this.tokens[this.position + this.options.minTokens - 1],
                },
            };
        }
        else {
            return {
                done: true,
                value: false,
            };
        }
    }
}
exports.TokensMap = TokensMap;
function generateMapsForFormats(id, data, tokens, options) {
    return Object
        .values(groupByFormat(tokens))
        .map((formatTokens) => new TokensMap(id, data, formatTokens, formatTokens[0].format, options));
}
exports.generateMapsForFormats = generateMapsForFormats;
function createTokensMaps(id, data, tokens, options) {
    return generateMapsForFormats(id, data, tokens, options);
}
exports.createTokensMaps = createTokensMaps;
//# sourceMappingURL=token-map.js.map