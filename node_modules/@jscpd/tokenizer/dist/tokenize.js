"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const reprism = require("reprism");
const formats_1 = require("./formats");
const token_map_1 = require("./token-map");
const grammar_loader_1 = require("./grammar-loader");
const ignore = {
    ignore: [
        {
            pattern: /(jscpd:ignore-start)[\s\S]*?(?=jscpd:ignore-end)/,
            lookbehind: true,
            greedy: true,
        },
        {
            pattern: /jscpd:ignore-start/,
            greedy: false,
        },
        {
            pattern: /jscpd:ignore-end/,
            greedy: false,
        },
    ],
};
const punctuation = {
    // eslint-disable-next-line @typescript-eslint/camelcase
    new_line: /\n/,
    empty: /\s+/,
};
const initializeFormats = () => {
    grammar_loader_1.loadLanguages();
    Object
        .keys(reprism.default.languages)
        .forEach((lang) => {
        if (lang !== 'extend' && lang !== 'insertBefore' && lang !== 'DFS') {
            reprism.default.languages[lang] = Object.assign(Object.assign(Object.assign({}, ignore), reprism.default.languages[lang]), punctuation);
        }
    });
};
initializeFormats();
function getLanguagePrismName(lang) {
    if (lang in formats_1.FORMATS && formats_1.FORMATS[lang].parent) {
        return formats_1.FORMATS[lang].parent;
    }
    return lang;
}
function tokenize(code, language) {
    let length = 0;
    let line = 1;
    let column = 1;
    function sanitizeLangName(name) {
        return name && name.replace ? name.replace('language-', '') : 'unknown';
    }
    function createTokenFromString(token, lang) {
        return [
            {
                format: lang,
                type: 'default',
                value: token,
                length: token.length,
            },
        ];
    }
    function calculateLocation(token, position) {
        const result = token;
        const lines = typeof result.value === 'string' && result.value.split ? result.value.split('\n') : [];
        const newLines = lines.length - 1;
        const start = {
            line,
            column,
            position
        };
        column = newLines >= 0 ? lines[lines.length - 1].length + 1 : column;
        const end = {
            line: line + newLines,
            column,
            position
        };
        result.loc = { start, end };
        result.range = [length, length + result.length];
        length += result.length;
        line += newLines;
        return result;
    }
    function createTokenFromFlatToken(token, lang) {
        return [
            {
                format: lang,
                type: token.type,
                value: token.content,
                length: token.length,
            },
        ];
    }
    function createTokens(token, lang) {
        if (token.content && typeof token.content === 'string') {
            return createTokenFromFlatToken(token, lang);
        }
        if (token.content && Array.isArray(token.content)) {
            let res = [];
            token.content.forEach((t) => (res = res.concat(createTokens(t, token.alias ? sanitizeLangName(token.alias) : lang))));
            return res;
        }
        return createTokenFromString(token, lang);
    }
    let tokens = [];
    const grammar = reprism.default.languages[getLanguagePrismName(language)];
    if (!reprism.default.languages[getLanguagePrismName(language)]) {
        console.warn('Warn: jscpd has issue with support of "' + getLanguagePrismName(language) + '"');
        return [];
    }
    reprism.default.tokenize(code, grammar)
        .forEach((t) => (tokens = tokens.concat(createTokens(t, language))));
    return tokens
        .filter((t) => t.format in formats_1.FORMATS)
        .map((token, index) => calculateLocation(token, index));
}
exports.tokenize = tokenize;
function setupIgnorePatterns(format, ignorePattern) {
    const language = getLanguagePrismName(format);
    const ignorePatterns = ignorePattern.map(pattern => ({
        pattern: new RegExp(pattern),
        greedy: false,
    }));
    reprism.default.languages[language] = Object.assign(Object.assign({}, ignorePatterns), reprism.default.languages[language]);
}
function createTokenMapBasedOnCode(id, data, format, options = {}) {
    const { mode, ignoreCase, ignorePattern } = options;
    const tokens = tokenize(data, format)
        .filter((token) => mode(token, options));
    if (ignorePattern)
        setupIgnorePatterns(format, options.ignorePattern);
    if (ignoreCase) {
        return token_map_1.createTokensMaps(id, data, tokens.map((token) => {
            token.value = token.value.toLocaleLowerCase();
            return token;
        }), options);
    }
    return token_map_1.createTokensMaps(id, data, tokens, options);
}
exports.createTokenMapBasedOnCode = createTokenMapBasedOnCode;
//# sourceMappingURL=tokenize.js.map