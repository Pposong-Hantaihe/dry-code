"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@jscpd/core");
const fast_glob_1 = require("fast-glob");
const tokenizer_1 = require("@jscpd/tokenizer");
const fs_extra_1 = require("fs-extra");
const safe_1 = require("colors/safe");
const fs_1 = require("fs");
const bytes = require("bytes");
function isFile(path) {
    try {
        const stat = fs_1.lstatSync(path);
        return stat.isFile();
    }
    catch (e) {
        // lstatSync throws an error if path doesn't exist
        return false;
    }
}
function skipNotSupportedFormats(options) {
    return (entry) => {
        const { path } = entry;
        const format = tokenizer_1.getFormatByFile(path, options.formatsExts);
        const shouldNotSkip = format && options.format && options.format.includes(format);
        if ((options.debug || options.verbose) && !shouldNotSkip) {
            console.log(`File ${path} skipped! Format "${format}" does not included to supported formats.`);
        }
        return shouldNotSkip;
    };
}
function skipBigFiles(options) {
    return (entry) => {
        const { stats, path } = entry;
        const shouldSkip = bytes.parse(stats.size) > bytes.parse(core_1.getOption('maxSize', options));
        if (options.debug && shouldSkip) {
            console.log(`File ${path} skipped! Size more then limit (${bytes(stats.size)} > ${core_1.getOption('maxSize', options)})`);
        }
        return !shouldSkip;
    };
}
function skipFilesIfLinesOfContentNotInLimits(options) {
    return (entry) => {
        const { path, content } = entry;
        const lines = content.split('\n').length;
        const minLines = core_1.getOption('minLines', options);
        const maxLines = core_1.getOption('maxLines', options);
        if (lines < minLines || lines > maxLines) {
            if ((options.debug || options.verbose)) {
                console.log(safe_1.grey(`File ${path} skipped! Code lines=${lines} not in limits (${minLines}:${maxLines})`));
            }
            return false;
        }
        return true;
    };
}
function addContentToEntry(entry) {
    const { path } = entry;
    const content = fs_extra_1.readFileSync(path).toString();
    return Object.assign(Object.assign({}, entry), { content });
}
function getFilesToDetect(options) {
    const pattern = options.pattern || '**/*';
    const patterns = options.path.map((path) => {
        if (isFile(path)) {
            return path;
        }
        return path.substr(path.length - 1) === '/' ? `${path}${pattern}` : `${path}/${pattern}`;
    });
    return fast_glob_1.sync(patterns, {
        ignore: options.ignore,
        onlyFiles: true,
        dot: true,
        stats: true,
        absolute: options.absolute,
        followSymbolicLinks: !options.noSymlinks,
    })
        .filter(skipNotSupportedFormats(options))
        .filter(skipBigFiles(options))
        .map(addContentToEntry)
        .filter(skipFilesIfLinesOfContentNotInLimits(options));
}
exports.getFilesToDetect = getFilesToDetect;
//# sourceMappingURL=files.js.map