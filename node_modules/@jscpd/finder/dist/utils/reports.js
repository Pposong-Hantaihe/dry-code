"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const process_1 = require("process");
const safe_1 = require("colors/safe");
exports.compareDates = (firstDate, secondDate) => {
    const first = new Date(firstDate);
    const second = new Date(secondDate);
    switch (true) {
        case first < second:
            return '=>';
        case first > second:
            return '<=';
        default:
            return '==';
    }
};
function escapeXml(unsafe) {
    return unsafe.replace(/[<>&'"]/g, function (c) {
        switch (c) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            case '\'': return '&apos;';
            case '"': return '&quot;';
        }
    });
}
exports.escapeXml = escapeXml;
function getPath(path, options) {
    return options.absolute ? path : path_1.relative(process_1.cwd(), path);
}
exports.getPath = getPath;
function getPathConsoleString(path, options) {
    return safe_1.bold(safe_1.green(getPath(path, options)));
}
exports.getPathConsoleString = getPathConsoleString;
function getSourceLocation(start, end) {
    return `${start.line}:${start.column} - ${end.line}:${end.column}`;
}
exports.getSourceLocation = getSourceLocation;
function generateLine(clone, position, line) {
    const lineNumberA = (clone.duplicationA.start.line + position).toString();
    const lineNumberB = (clone.duplicationB.start.line + position).toString();
    if (clone.duplicationA.blame && clone.duplicationB.blame) {
        return [
            lineNumberA,
            clone.duplicationA.blame[lineNumberA] ? clone.duplicationA.blame[lineNumberA].author : '',
            clone.duplicationA.blame[lineNumberA] && clone.duplicationB.blame[lineNumberB]
                ? exports.compareDates(clone.duplicationA.blame[lineNumberA].date, clone.duplicationB.blame[lineNumberB].date)
                : '',
            lineNumberB,
            clone.duplicationB.blame[lineNumberB] ? clone.duplicationB.blame[lineNumberB].author : '',
            safe_1.grey(line),
        ];
    }
    else {
        return [lineNumberA, lineNumberB, safe_1.grey(line)];
    }
}
exports.generateLine = generateLine;
function convertStatisticToArray(format, statistic) {
    return [
        format,
        `${statistic.sources}`,
        `${statistic.lines}`,
        `${statistic.tokens}`,
        `${statistic.clones}`,
        `${statistic.duplicatedLines} (${statistic.percentage}%)`,
        `${statistic.duplicatedTokens} (${statistic.percentageTokens}%)`,
    ];
}
exports.convertStatisticToArray = convertStatisticToArray;
//# sourceMappingURL=reports.js.map